<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Kids' Coloring Fun</title>
    <style>
        #drawingCanvas {
            border: 1px solid black;
            background-color: white;
        }
        body {
            background: linear-gradient(135deg, #ffd3e2, #ffedbc);
            font-family: Arial, sans-serif;
            text-align: center;
        }
        #colorPalette {
            margin-top: 10px;
        }
        .thumbnail {
            display: inline-block;
            margin: 5px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <h1>Welcome to Kids' Coloring Fun</h1>
    <div>
        <label>Choose Color: </label>
        <input type="color" id="colorPicker">
    </div>
    <div>
        <label>Brush Size: </label>
        <input type="number" id="brushSize" value="5" min="1" max="50">
    </div>
    <button onclick="clearCanvas()">Clear Canvas</button>
    <button onclick="toggleShapeMode()">Draw Shapes</button>
    <button onclick="toggleEraserMode()">Eraser</button>
    <button onclick="toggleBucketMode()">Bucket Fill</button>
    <button onclick="saveCanvas()">Save Image</button>
    <input type="file" id="imageLoader" accept="image/*">
    <button onclick="loadImage()">Load Image</button>
    <hr>
    <h2>Choose a Template</h2>
    <div id="thumbnails">
        <!-- Thumbnails will be added dynamically here -->
    </div>
    <div id="colorPalette">
        <div class="color" style="background-color: red;"></div>
        <div class="color" style="background-color: green;"></div>
        <div class="color" style="background-color: blue;"></div>
        <div class="color" style="background-color: yellow;"></div>
        <div class="color" style="background-color: purple;"></div>
        <div class="color" style="background-color: pink;"></div>
        <div class="color" style="background-color: orange;"></div>
        <div class="color" style="background-color: brown;"></div>
    </div>

    <canvas id="drawingCanvas" width="800" height="600"></canvas>
    <canvas id="brushIndicatorCanvas" style="position: absolute; top: 0; left: 0;"></canvas>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const context = canvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const brushSize = document.getElementById('brushSize');
        const imageLoader = document.getElementById('imageLoader');
        const colorPalette = document.getElementById('colorPalette');
        const thumbnailsContainer = document.getElementById('thumbnails');
        const brushIndicatorCanvas = document.getElementById('brushIndicatorCanvas');
        const brushIndicatorContext = brushIndicatorCanvas.getContext('2d');
        let isDrawing = false;
        let isErasing = false;
        let isShapeMode = false;
        let isFilling = false;
        let lastX = 0;
        let lastY = 0;
        let shapeStartX = 0;
        let shapeStartY = 0;
        let selectedShape = 'rectangle';
        let currentColor = 'black';
        let currentTemplate = new Image();

        const templateImages = [
            'assets/IMG_6883.PNG',
            'assets/IMG_6884.PNG',
            'assets/IMG_6885.PNG',
            'assets/IMG_6886.PNG',
            'assets/IMG_6887.PNG',
            'assets/IMG_6888.PNG',
            'assets/IMG_6889.PNG',
            'assets/IMG_6890.PNG',
            'assets/IMG_6891.PNG',
            'assets/IMG_6892.PNG',
            'assets/IMG_6893.PNG',
            'assets/IMG_6894.PNG',
            'assets/IMG_6895.PNG',
            'assets/IMG_6896.PNG'
        ];

        // Load a default blank template
        loadTemplate('blank_template.png');

        // Create thumbnails for templates
        templateImages.forEach((imageUrl) => {
            const thumbnail = document.createElement('div');
            thumbnail.className = 'thumbnail';
            thumbnail.innerHTML = `<img src="${imageUrl}" width="50" height="50" alt="Template">`;
            thumbnail.onclick = () => loadTemplate(imageUrl);
            thumbnailsContainer.appendChild(thumbnail);
        });

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            [lastX, lastY] = [e.offsetX, e.offsetY];
            if (isShapeMode) {
                [shapeStartX, shapeStartY] = [e.offsetX, e.offsetY];
            } else if (isFilling) {
                fillArea(e.offsetX, e.offsetY, currentColor);
            }
        });

        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', () => {
            isDrawing = false;
            if (isShapeMode) {
                drawShape();
            }
        });

        canvas.addEventListener('mouseout', () => {
            isDrawing = false;
            if (isShapeMode) {
                drawShape();
            }
        });

        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);

        function handleTouchStart(e) {
            const touch = e.touches[0];
            [lastX, lastY] = [touch.clientX - canvas.getBoundingClientRect().left, touch.clientY - canvas.getBoundingClientRect().top];
        }

        function handleTouchMove(e) {
            e.preventDefault();
            const touch = e.touches[0];
            [lastX, lastY] = [touch.clientX - canvas.getBoundingClientRect().left, touch.clientY - canvas.getBoundingClientRect().top];
            draw();
        }

        function handleTouchEnd() {
            isDrawing = false;
            if (isShapeMode) {
                drawShape();
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            context.strokeStyle = currentColor;
            context.lineWidth = brushSize.value;
            context.lineCap = 'round';

            context.beginPath();
            context.moveTo(lastX, lastY);
            context.lineTo(e.offsetX, e.offsetY);
            context.stroke();

            [lastX, lastY] = [e.offsetX, e.offsetY];
        }

        function drawShape() {
            context.strokeStyle = currentColor;
            context.lineWidth = brushSize.value;
            context.lineCap = 'round';

            if (selectedShape === 'rectangle') {
                const width = e.offsetX - shapeStartX;
                const height = e.offsetY - shapeStartY;
                context.strokeRect(shapeStartX, shapeStartY, width, height);
            } else if (selectedShape === 'circle') {
                const radius = Math.sqrt(
                    Math.pow(e.offsetX - shapeStartX, 2) + Math.pow(e .offsetY - shapeStartY, 2)
                );
                context.beginPath();
                context.arc(shapeStartX, shapeStartY, radius, 0, 2 * Math.PI);
                context.stroke();
            }
        }

        function loadTemplate(imageUrl) {
            currentTemplate.src = imageUrl;
            currentTemplate.onload = function () {
                context.clearRect(0, 0, canvas.width, canvas.height);
                context.drawImage(currentTemplate, 0, 0, canvas.width, canvas.height);
            };
        }

        function saveCanvas() {
            const dataURL = canvas.toDataURL();
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'my_coloring.png';
            link.click();
        }

        imageLoader.addEventListener('change', loadImage);

        function loadImage() {
            const file = imageLoader.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function (e) {
                    const img = new Image();
                    img.onload = function () {
                        context.clearRect(0, 0, canvas.width, canvas.height);
                        context.drawImage(img, 0, 0);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function fillArea(x, y, fillColor) {
            // Implementation of the bucket fill tool
            // ...

            // Function to fill an area with a selected color
            // ...

        }

        function updateBrushIndicator() {
            brushIndicatorContext.clearRect(0, 0, canvas.width, canvas.height);
            brushIndicatorContext.strokeStyle = currentColor;
            brushIndicatorContext.lineWidth = brushSize.value * 2;
            brushIndicatorContext.lineCap = 'round';

            brushIndicatorContext.beginPath();
            brushIndicatorContext.arc(lastX, lastY, brushSize.value, 0, Math.PI * 2);
            brushIndicatorContext.stroke();
        }
    </script>
</body>
</html>